import pandas as pd
import requests
import gzip
import json
from io import BytesIO
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.preprocessing import OneHotEncoder, StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.neural_network import MLPClassifier
from sklearn.metrics import classification_report
from scipy.sparse import hstack
import joblib

def fetch_cve_data(url):
    try:
        response = requests.get(url)
        response.raise_for_status()
        with gzip.open(BytesIO(response.content)) as file:
            data = json.load(file)
        
        # Convertir a DataFrame
        df = pd.json_normalize(data['CVE_Items'])
        
        # Eliminar columnas no deseadas
        columns_to_drop = [
            'publishedDate', 
            'lastModifiedDate', 
            'cve.data_type', 
            'cve.data_format', 
            'cve.data_version'
        ]
        df = df.drop(columns=[col for col in columns_to_drop if col in df.columns], errors='ignore')
        
        return df
    except requests.exceptions.RequestException as e:
        print(f"Error en la solicitud: {e}")
        return pd.DataFrame() 
    except ValueError as e:
        print(f"Error al decodificar JSON: {e}")
        return pd.DataFrame() 

def preprocess_data(data, vectorizer=None, encoder=None, scaler=None):
    if 'cve.description.description_data' not in data.columns:
        print("La columna 'description' no est치 en los datos.")
        return pd.DataFrame(), pd.Series()

    data['description'] = data['cve.description.description_data'].apply(lambda x: ' '.join(d['value'] for d in x) if isinstance(x, list) else '')

    if 'impact.baseMetricV3.impactScore' not in data.columns:
        print("La columna 'impact_score' no est치 en los datos.")
        return pd.DataFrame(), pd.Series()

    data['impact_score'] = pd.to_numeric(data['impact.baseMetricV3.impactScore'], errors='coerce').fillna(0)

    if 'cve.problemtype.problemtype_data' not in data.columns:
        print("La columna 'vulnerability_type' no est치 en los datos. Usando un tipo ficticio.")
        data['vulnerability_type'] = 'unknown'
    else:
        data['vulnerability_type'] = data['cve.problemtype.problemtype_data'].apply(lambda x: 'unknown' if pd.isna(x) else 'known')

    if vectorizer is None:
        vectorizer = TfidfVectorizer(stop_words='english')
    X_text = vectorizer.fit_transform(data['description'])

    if encoder is None:
        encoder = OneHotEncoder(sparse_output=False)
    X_categoricals = encoder.fit_transform(data[['vulnerability_type']])

    if scaler is None:
        scaler = StandardScaler()
    X_numeric = scaler.fit_transform(data[['impact_score']])

    X_combined = hstack([X_text, X_categoricals, X_numeric])

    if 'vulnerability_label' not in data.columns:
        print("La columna 'vulnerability_label' no est치 en los datos. Usando una etiqueta ficticia.")
        data['vulnerability_label'] = 'unknown'

    y = data['vulnerability_label']
    return X_combined, y, vectorizer, encoder, scaler

def fetch_and_combine_cve_data(urls):
    dfs = [fetch_cve_data(url) for url in urls]
    combined_df = pd.concat(dfs, ignore_index=True)
    return combined_df

cve_urls = [
    'https://nvd.nist.gov/feeds/json/cve/1.1/nvdcve-1.1-2024.json.gz',
]

print("Descargando datos de CVE...")
data = fetch_and_combine_cve_data(cve_urls)
print(f"Datos combinados: {data.shape[0]} filas y {data.shape[1]} columnas.")
print(f"Columnas disponibles: {data.columns.tolist()}")

X, y, vectorizer, encoder, scaler = preprocess_data(data)

if X.shape[0] > 0 and y.shape[0] > 0:
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

    print("Entrenando el modelo...")
    model = MLPClassifier(hidden_layer_sizes=(100, 50), max_iter=1000, random_state=42)
    model.fit(X_train, y_train)

    y_pred = model.predict(X_test)
    print(classification_report(y_test, y_pred))

    print("Guardando el modelo y los preprocesadores...")
    joblib.dump(model, 'cve_vulnerability_model.pkl')
    joblib.dump(vectorizer, 'vectorizer.pkl')
    joblib.dump(encoder, 'encoder.pkl')
    joblib.dump(scaler, 'scaler.pkl')
else:
    print("Datos insuficientes para entrenamiento del modelo.")
